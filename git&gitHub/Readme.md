- [Version Control](#1version-control)
  - [Finding the differences](#finding-the-differences)
  - [Generating Diff files](#generating-diff-files)
  - [Applying changes](#applying-changes)
  - [First steps with git](#first-steps-with-git)
  - [Life cycle of each track file](#life-cycle-of-each-track-file) 
  -[Terms and definitions](#terms-and-definitions)
    <br>
- [Advance Git interaction](#advance-git-interaction) 
- [Skipping the stagin area](#skipping-the-stagin-area) 
- [Getting more information about our changes](#getting-more-informations-about-our-changes) 
- [Deleting and Renaming Files]()

## 1.Version Control
 
### finding the differences

dif take two directroy ar two files and show the differences between them in a few formates
![Alt text](image.png)

when we call diff command we get only the lines they are different between two files .<remove from the first line ,> stand to added to the second file

![Alt text](image-1.png)

- in this example 5c5,6 mean 5th line in the first file replaced by 5,6 in the second file (c mean change )

- 11a13-15 the differences is not obvious here so we can use

```git
diff -u
```

![Alt text](image-2.png)

<!-- wdiff highlights words that changed inside the file
 , meld , Kdiff3  highlighted differences using colors  -->

### Generating diff files

diff -u oldFile new file > changes.diff
**_as a reminder the greater than sign redirects the output of the diff command to a file so with this command we generatig a file called change.diff with the contents of diff -u command_**

- by using -u flag we include more context which help the person reading the file understand what going on with the change
- the generated file usually referred as (diff or patch) file is includes all the changes between the old file and the new one plus the additional context needed to understand the changes and to apply those changes back to the original file

### applying changes

- but we don't need to apply these changes manually because there is a command called **patch** to do exactly this patch takes a file generated by diff and applies the changes to the original file.

![Alt text](image-3.png)

now we have the diff file and we want to apply it to our script so we use patch command

 <!-- we use less than sympol to redirect the contents fo the file to standart input -->``

```shell
patch nameOfTheFileWeWannaPatchIn  <  changes.diff
```

![Alt text](image-4.png)

<br/>

we have seen up till now how we can use existing tools to extract differences between versions of files. and apply those changes back to the original files. Those tools are very useful but most of the time , we won't be using them directly instead , we'll use them through a
**_Version Control System (VCS)_** : which keeps track of the changes that we make to our files(keeps track of all the different versions that we create as we save our changes), by using VCS we can know when the changes were made and who made them . it also lets us easily revert a change, and makes collaboration easier by allowing us to merge changes from lots of different sources.
![Alt text](image-5.png)

---

### First Steps with Git

we said earlier that VCS track who and when the changes are made for this to work we need to till git who we are to do this we need to use 'git config and setting the values of user email and user name

```git
git config -l // to check out our current configurations
git config --global user.email "me@example"
git config --global user.name "MyName"
```

we used the --global flag to state that we want set this value for all git repositories that we would use.

when that done there is two way to start git repositories

1. git init: to create one from scratch
2. git clone: make copy of repository that already exist some where else

```git
git init

```

when we run git init we initialize empty git repository in the current directory

which create .git directory which contains:
![Alt text](image-6.png)
we can think of it as data base for our get project that store the changes and the change history we saw that .git contains bunch of different files and directories we don't touch any of these files directly we always interact with them throgh git commands
so when ever we clone a repo this git directory is copied for our computer and when ever we run git init to create a new repo a new git directory is initialize

![Alt text](image-7.png)

The git directory acts as a database for all the changes tracked in Git. and the working tree acts as a sandbox where we can edit the current versions of the files(tracked or new files which not tracked yet).

to make git track our file we should add it to the project using

```git
git add
```

with this command we adding our file to staging area

![Alt text](image-8.png)

we can use 'git status' command to get some informations about the current working tree and pending changes

to get our files that in staggine area to get it committed into .git directory we run

```git
git commit
```

> You can’t commit with an empty commit message. and if you tried it The commit will be aborted
> [commit style](https://commit.style/)

### life cycle of each track file

Git project will consist of three sections :

1. The Git directory which contains the history of all the files and changes.
2. the working tree which contains the current state of the project, including any changes that we've made.
3. the staging area which contains the changes that have been marked to be included in the next commit(All files that are staged will be part of the next snapshot we take).

![Alt text](image-9.png)

---

### Terms and definitions

Commit: A command to make edits to multiple files and treat that collection of edits as a single change

Commit files: A stage where the changes made to files are safely stored in a snapshot in the Git directory

Commit message: A summary and description with contextual information on the parts of the code or configuration of the commit change

Diff: A command to find the differences between two files

DNS zone file: A configuration file that specifies the mappings between IP addresses and host names in your network

Git: A free open source version control system available for installation on Unix based platforms, Windows and macOS

Git directory: A database for a Git project that stores the changes and the change history

Git log: A log that displays commit messages

Git staging area: A file maintained by Git that contains all the information about what files and changes are going to go into the next commit

Modified files: A stage where changes have been made to a file, but the have not been stored or committed

Patch: A command that can detect that there were changes made to the file and will do its best to apply the changes

Repository: An organization system of files that contain separate software projects

Source Control Management (SCM): A tool similar to VCS to store source code

Stage files: A stage where the changes to files are ready to be committed

Tracked: A file’s changes are recorded

Untracked: A file’s changes are not recorded

Version control systems (VCS): A tool to safely test code before releasing it, allow multiple people collaborate on the same coding projects together, and stores the history of that code and configuration

<!-- Module 2 -->

## 2.Advance git interaction

### Skipping the Stagin Area

```git
git commit -a

# a shortcut to stage any changes to tracked files and commit them in one step(if modified file has been never committed to the repo , we'll still need  to use git add to tracked first  )
```

when we use -a shortcut we skip the stagin area meaning , we can't add any other changes before creating the commit

**What is HEAD and where is it heading?**
Git uses the HEAD alias to represent the currently checked-out snapshot of your project.this let us know what the contents of our working directory should be.

<!-- we'll see head use when we learn how  to undo things and perform  rollbacks. -->

### Getting More Informations About Our Changes

we have seen how git log show us the list of commits made in the current Git repository. By default is , it prints the commit message, the author, and the date of the change. This is useful, but if we're combing through a history of changes in a repo to try and find what caused the latest outage, we'll probably also need _to look at the actual lines that changed in each commit_. To do this with git log, we can use the -p flag.

```git
git log -p
# p comes from patch cause -p will give the patch that has been created
```

another option if we don't wanna scroll down until find the commit that we're actually interested in

```git
git show  CommitIdAsParameter
```

another interested flag

```git
git log --stat
# this will caus git log to show some stats about the changes in the commit like which files were changed and how many lines added or removed
```

now what about changes that haven't been committed yet?

<!-- unstaged changes -->

```git
git diff
# if our change was bigger and included several files , we could  pass a file by parameter to see the differences relevant to that specific file instead of all files at the same time.


# git diff by default shows unstaged changes  but if we wanna see the differences that staged but not commited we can use

git diff --staged
```

Something else we can do to review changes before adding them is to use

```git
git add -p
#when we use this flag Git will show us the change being added and ask if we want to stage it or not this way we can detect if there's any changes that  we con't want to commit
```

### Deleting and Renaming Files

we can remove files from ours repository with the `git rm ` which will stop the file from being tracked by git and remove it from the git directory. File removals go through the same general workflow that we've seen. So we'll need to write a commit message as to why we've deleted them.

and we can ust `git mv` to rename files in the repository after rename a file and run `git status` The status shows us that the file was renamed and clearly displays the old and new names. As with the previous example, the change is staged, but not committed.

If there are files that get automatically generated by our scripts, or our operating system generates artifacts that we don't want in our repo, we'll want to ignore them so that they don't add noise to the output of git status. To do this, we can use the gitignore file.
Play video starting at :3:3 and follow transcript3:03
Inside this file, we'll specify rules to tell git which files to skip for the current repo. For example, if we're working on an OSX computer, we'll probably want to ignore the dot DS_store file, which is automatically generated by the operating system. To do this, we'll create a .gitignore file containing the name of this file.
his file needs to get tracked just like the rest of the files in the repo.

> Remember that the dot prefix in a Unix-like file system indicates that the file or directory is hidden and won't show up when you do the normal directory listing.

### Undoing Changes Before Commiting

Being able to revert our changes is one of the most powerful features offered by version control systems. There's a bunch of different techniques available depending on which changes we need to undo.

- **Undoing Unstaged Changes**
  `git checkout fileNameWeWannaRevert` git checkout restores files to the latest stored snapshot(which can be either commited or staged), reverting any changes before staging.

So if we've made additional changes to a file after we've staged it, we can restore the file to the earlier stage version and by using _-p_ flag we can check out individual changes instead of the whole file This will ask us change by change if we want to go back to the previous snapshot or not.

<!-- think of it like you're checkingout the original file from the latest storage snapshot -->

<!--

Check out the following links for more information:

https://git-scm.com/doc

https://www.mercurial-scm.org/

https://subversion.apache.org/

https://en.wikipedia.org/wiki/Version_control













 -->
